 #                                                                                         ob 混淆

> 混淆实际上是把js核心代码计算逻辑混淆掉从而增加阅读难度的一种方法。
>
> 混淆之后的js代码强度取决于混淆之前代码强度
>
> 逆向难度 = 原始js代码的难度 + 混淆器的难度

## 1.如何确定一个网是不是cookie混淆的加密网站?

```js
鼠标右键查看网页源代码，然后把cookie的所有东西删掉，然后刷新页面，就可以看到混淆代码了
```

## 2.确定网站是不是动态混淆加密的网站

```js
cookie加密的网站，是动态的概率超过90%以上
或者
清除cookie，然后刷新页面进行对比，看每次请求的代码是不是一样的，来确定是不是动态的	
```

## 3.如何处理动态的混淆s

```js
把动态的换成静态的，将代码固定住通过overrides加载固定好的js，固定住可能会出现问题但不影响调试
先找到静态的逻辑，然后再找动态的，如果静态的通了是最理想的情况，没通再去看静态里面有哪些动态点，在针对动态点进行处理   
这样操作，即使代码跟丢的时候也方便调试
```

## 4. 跟值注意

```js
跟代码注意，首先把断点放在js代码第一行，不能让代码自己的debugger去断住，并不是我们的所期待的
要让代码走我们自己打的断点，而不是代码控制debugger位置
*注意：动态的js打断点，能不能打中，能打中，打中之后会乱的可能性比较大；技巧是建议是打`script`断点然后刷新页面，刷新之后可能断到别的位置，第一种可能是cookie有效，没有清除cookie，第二种就是断到谷歌浏览器插件上(因为谷歌浏览器插件会优先加载js)
```

## 5. OB混淆特征

```javascript
ob混淆呢具有以下特征：
　　1.具有大数组的情况
　　2.数组移位（有内存泄露风险、建议不格式化），自执行函数，进行移位操作，有明显的 push、shift 关键字
　　3.解密函数（有内存泄露风险、建议不格式化）------可能有定时器--------（看加密的开关开启数量）
　　4.实际代码+控制流平坦化（整体ob的强度几乎完全取决于这段的代码强度，这里面是加密前的逻辑）
　　5.控制流平坦化+无限debugger自执行函数+死代码注入。一般情况下不会有业务逻辑所以不要问，ob、sojson如何破解。这些东西只是一层壳，破解强度完全取决于第四段代码，也就是其它网站作者写的代码强度！
　　6.函数名和变量名通常以 _0x 或者 0x 开头，后接 1~6 位数字或字母组合
```

## 6. OB混淆格式化检测内存溢出

```js
ob混淆的格式化检测一共有三处:
1.数组移位
2.解密函数
3.定时任务函数

解决方法就是hook：
RegExp.prototype.test = function (){
    return true
}
```



